<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>sdk&#x2F;src&#x2F;rpc.js</title>
	<link href="http://docs.openf2.com/css/F2.css" rel="stylesheet">
	<link href="http://docs.openf2.com/css/prettify.css" rel="stylesheet">
	<link href="http://docs.openf2.com/css/F2-docs.css" rel="stylesheet">
	<link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
	<style type="text/css" media="print">
		#toc {
			display: none;
		}
		.row .span9 {
			margin-left: 0;
		}
	</style>
</head>
<body>

<div id="doc">
	<div class="navbar navbar-fixed-top">
		<div class="navbar-inner">
			<div class="container">
				<a class="brand" href="index.html">F2: Financial Framework</a>
				<div class="tagline-divider"></div>
				<div class="tagline">Helping you build smarter financial apps</div>
				<ul class="nav pull-right">
					<li><a href="http://www.openF2.com">OpenF2.com</a></li>
					<li class="divider-vertical"></li>
					<li class="active"><a href="../../index.html">Docs</a></li>
					<li class="divider-vertical"></li>
					<li><a href="../sdk/docs/">SDK</a></li>
					<li class="divider-vertical"></li>
					<li><a href="https://github.com/OpenF2/F2/">Fork F2 on GitHub</a></li>
					<li class="divider-vertical"></li>
					<li><a class="download" href="https://github.com/OpenF2/F2/zipball/master">Download <i class="icon-download"></i></a></li>
					<li class="divider-vertical"></li>
					<li><a href="https://github.com/OpenF2/F2/commits/master" class="version">v 0.10.2</a></li>
				</ul>
			</div>
		</div>
	</div>

	<div class="container">
		<div class="row">
			<div id="toc" class="span3">
				<ul class="nav nav-list nav-pills nav-stacked">
					<li class="nav-header">Classes</li>
						
		<li><a href="..&#x2F;classes/F2.html">F2</a></li>
	
		<li><a href="..&#x2F;classes/F2.App.html">F2.App</a></li>
	
		<li><a href="..&#x2F;classes/F2.AppManifest.html">F2.AppManifest</a></li>
	
		<li><a href="..&#x2F;classes/F2.AppManifest.AppContent.html">F2.AppManifest.AppContent</a></li>
	
		<li><a href="..&#x2F;classes/F2.Constants.html">F2.Constants</a></li>
	
		<li><a href="..&#x2F;classes/F2.Constants.Css.html">F2.Constants.Css</a></li>
	
		<li><a href="..&#x2F;classes/F2.Constants.Events.html">F2.Constants.Events</a></li>
	
		<li><a href="..&#x2F;classes/F2.Constants.Sockets.html">F2.Constants.Sockets</a></li>
	
		<li><a href="..&#x2F;classes/F2.Constants.Views.html">F2.Constants.Views</a></li>
	
		<li><a href="..&#x2F;classes/F2.ContainerConfiguration.html">F2.ContainerConfiguration</a></li>
	
		<li><a href="..&#x2F;classes/F2.Events.html">F2.Events</a></li>
	
		<li><a href="..&#x2F;classes/F2.Rpc.html">F2.Rpc</a></li>
	
		<li><a href="..&#x2F;classes/F2.UI.html">F2.UI</a></li>
	
		<li><a href="..&#x2F;classes/F2.UI.MaskConfiguration.html">F2.UI.MaskConfiguration</a></li>
	
		<li><a href="..&#x2F;classes/F2.UI.Modals.html">F2.UI.Modals</a></li>
	

					<li class="nav-header">View Options</li>
					<li id="viewOptions">
	<label class="checkbox" for="show-inherited">
		<input type="checkbox" id="show-inherited" value="inherited">
		Inherited
	</label>
	<label class="checkbox" for="show-protected">
		<input type="checkbox" id="show-protected" value="protected">
		Protected
	</label>
	<label class="checkbox" for="show-private">
		<input type="checkbox" id="show-private" value="private">
		Private
	</label>
	<label class="checkbox" for="show-deprecated">
		<input type="checkbox" id="show-deprecated" value="deprecated">
		Deprecated
	</label>
</li>
				</ul>
			</div>
			<div id="main" class="span9">
				<h1 class="file-heading">File: sdk&#x2F;src&#x2F;rpc.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * Handles socket communication between the Container and secure Apps
 * @class F2.Rpc
 *&#x2F;
F2.extend(&#x27;Rpc&#x27;, (function(){
	
	var _apps = {};
	var _callbacks = {};
	var _secureAppPagePath = &#x27;&#x27;;
	var _rAppCall = new RegExp(&#x27;^&#x27; + F2.Constants.Sockets.APP_RPC);
	var _rEvents = new RegExp(&#x27;^&#x27; + F2.Constants.Sockets.EVENT);
	var _rRpc = new RegExp(&#x27;^&#x27; + F2.Constants.Sockets.RPC);
	var _rRpcCallback = new RegExp(&#x27;^&#x27; + F2.Constants.Sockets.RPC_CALLBACK);
	var _rSocketLoad = new RegExp(&#x27;^&#x27; + F2.Constants.Sockets.LOAD);

	&#x2F;**
	 * Creates a socket connection from the App to the Container using 
	 * &lt;a href=&quot;http:&#x2F;&#x2F;easyxdm.net&quot; target=&quot;_blank&quot;&gt;easyXDM&lt;&#x2F;a&gt;.
	 * @method _createAppToContainerSocket
	 * @private
	 *&#x2F;
	var _createAppToContainerSocket = function() {

		var isLoaded = false;
		var app = false;

		var socket = new easyXDM.Socket({
			onMessage: function(message, origin){

				&#x2F;&#x2F; handle Socket Load
				if (!isLoaded &amp;&amp; _rSocketLoad.test(message)) {
					message = message.replace(_rSocketLoad, &#x27;&#x27;);
					var appParts = F2.parse(message);

					&#x2F;&#x2F; make sure we have the App and AppManifest
					if (appParts.length == 2) {
						app = appParts[0]; &#x2F;&#x2F; assigning app object to closure
						var appManifest = appParts[1];

						&#x2F;&#x2F; save app locally
						_apps[app.instanceId] = {
							app:app,
							socket:socket
						};

						F2.registerApps([app], [appManifest]);
						isLoaded = true;
					}

				&#x2F;&#x2F; pass everyting else to _onMessage
				} else {
					_onMessage(app, message, origin);
				}
			}
		});
	};

	&#x2F;**
	 * Creates a socket connection from the Container to the App using 
	 * &lt;a href=&quot;http:&#x2F;&#x2F;easyxdm.net&quot; target=&quot;_blank&quot;&gt;easyXDM&lt;&#x2F;a&gt;.
	 * @method _createContainerToAppSocket
	 * @private
	 * @param {F2.App} app The App object
	 * @param {F2.AppManifest} appManifest The AppManifest object
	 *&#x2F;
	var _createContainerToAppSocket = function(app, appManifest) {

		var container = $(&#x27;#&#x27; + app.instanceId);
		container = container.is(&#x27;.&#x27; + F2.Constants.Css.APP_CONTAINER)
			? container
			: container.find(&#x27;.&#x27; + F2.Constants.Css.APP_CONTAINER);

		if (!container.length) {
			F2.log(&#x27;Unable to locate app in order to establish secure connection.&#x27;);
			return;
		}

		var iframeProps = {
			scrolling:&#x27;no&#x27;,
			style:{
				width:&#x27;100%&#x27;
			}
		};

		if (app.height) {
			iframeProps.style.height = app.height + &#x27;px&#x27;;
		}

		var socket = new easyXDM.Socket({
			remote: _secureAppPagePath,
			container: container.get(0),
			props:iframeProps,
			onMessage: function(message, origin) {
				&#x2F;&#x2F; pass everything to _onMessage
				_onMessage(app, message, origin);
			},
			onReady: function() {
				socket.postMessage(F2.Constants.Sockets.LOAD + F2.stringify([app, appManifest]));
			}
		});

		return socket;
	};

	&#x2F;**
	 * @method _createRpcCallback
	 * @private
	 * @param {string} instanceId The App&#x27;s Instance ID
	 * @param {function} callbackId The callback ID
	 * @return {function} A function to make the RPC call
	 *&#x2F;
	var _createRpcCallback = function(instanceId, callbackId) {
		return function() {
			F2.Rpc.call(
				instanceId,
				F2.Constants.Sockets.RPC_CALLBACK,
				callbackId,
				[].slice.call(arguments).slice(2)
			);
		};
	};

	&#x2F;**
	 * Handles messages that come across the sockets
	 * @method _onMessage
	 * @private
	 * @param {F2.App} app The App object
	 * @param {string} message The socket message
	 * @param {string} origin The originator
	 *&#x2F;
	var _onMessage = function(app, message, origin) {

		var obj;

		function parse(regEx, message) {
			return F2.parse(message.replace(regEx, &#x27;&#x27;));
		}

		&#x2F;&#x2F; handle App Call
		if (_rAppCall.test(message)) {
			obj = parse(_rAppCall, message);
			app[obj.functionName].apply(app, obj.params);

		&#x2F;&#x2F; handle RPC
		} else if (_rRpc.test(message)) {
			obj = parse(_rRpc, message);

			&#x2F;&#x2F; if obj.callbacks
			&#x2F;&#x2F;   for each callback
			&#x2F;&#x2F;     for each params
			&#x2F;&#x2F;       if callback matches param
			&#x2F;&#x2F;        replace param with _createRpcCallback(app.instanceId, callback)
			if (obj.params &amp;&amp; obj.params.length &amp;&amp; obj.callbacks &amp;&amp; obj.callbacks.length) {
				$.each(obj.callbacks, function(i, c) {
					$.each(obj.params, function(i, p) {
						if (c == p) {
							obj.params[i] = _createRpcCallback(app.instanceId, c);
						}
					});
				});
			}
			&#x2F;&#x2F; parse function path
			var path = String(obj.functionName).split(&#x27;.&#x27;);
			var func = window;
			for (var i = 0; i &lt; path.length; i++) {
				if (func[path[i]] === undefined) {
					func = undefined;
					break;
				}
				func = func[path[i]];
			}
			&#x2F;&#x2F; if we found the function, call it
			if (func !== undefined) {
				func.apply(func, obj.params);
			} else {
				F2.log(&#x27;Unable to locate RPC function: &#x27; + obj.functionName);
			}

		&#x2F;&#x2F; handle RPC Callback
		} else if (_rRpcCallback.test(message)) {
			obj = parse(_rRpcCallback, message);
			if (_callbacks[obj.functionName] !== undefined) {
				_callbacks[obj.functionName].apply(_callbacks[obj.functionName], obj.params);
				delete _callbacks[obj.functionName];
			}

		&#x2F;&#x2F; handle Events
		} else if (_rEvents.test(message)) {
			obj = parse(_rEvents, message);
			F2.Events._socketEmit.apply(F2.Events, obj);
		}
	};

	&#x2F;**
	 * Registers a callback function
	 * @method _registerCallback
	 * @private
	 * @param {function} callback The callback function
	 * @return {string} The callback ID
	 *&#x2F;
	var _registerCallback = function(callback) {
		var callbackId = F2.guid();
		_callbacks[callbackId] = callback;
		return callbackId;
	};

	return {
		&#x2F;**
		 * Broadcast an RPC function to all sockets
		 * @method broadcast
		 * @param {string} messageType The message type
		 * @param {Array} params The parameters to broadcast
		 *&#x2F;
		broadcast:function(messageType, params) {
			&#x2F;&#x2F; check valid messageType
			var message = messageType + F2.stringify(params);
			$.each(_apps, function(i, a) {
				a.socket.postMessage(message);
			});
		},
		&#x2F;**
		 * Calls a remote function
		 * @method call
		 * @param {string} instanceId The App&#x27;s Instance ID
		 * @param {string} messageType The message type
		 * @param {string} functionName The name of the remote function
		 * @param {Array} params An array of parameters to pass to the remote
		 * function. Any functions found within the params will be treated as a
		 * callback function.
		 *&#x2F;
		call:function(instanceId, messageType, functionName, params) {
			&#x2F;&#x2F; loop through params and find functions and convert them to callbacks
			var callbacks = [];
			$.each(params, function(i, e) {
				if (typeof e === &quot;function&quot;) {
					var cid = _registerCallback(e);
					params[i] = cid;
					callbacks.push(cid);
				}
			});
			&#x2F;&#x2F; check valid messageType
			_apps[instanceId].socket.postMessage(
				messageType + F2.stringify({
					functionName:functionName,
					params:params,
					callbacks:callbacks
				})
			);
		},

		&#x2F;**
		 * Init function which tells F2.Rpc whether it is running at the Container-
		 * level or the App-level. This method is generally called by
		 * F2.{{#crossLink &quot;F2&#x2F;init&quot;}}{{&#x2F;crossLink}}
		 * @method init
		 * @param {string} [secureAppPagePath] The
		 * {{#crossLink &quot;F2.ContainerConfiguration&quot;}}{{&#x2F;crossLink}}.secureAppPagePath
		 * property
		 *&#x2F;
		init:function(secureAppPagePath) {
			_secureAppPagePath = secureAppPagePath;
			if (!_secureAppPagePath) {
				_createAppToContainerSocket();
			}
		},

		&#x2F;**
		 * Determines whether the Instance ID is considered to be &#x27;remote&#x27;. This is
		 * determined by checking if 1) the App has an open socket, 2) where the
		 * instance of RPC is running (Container or App) and 3) where the App is
		 * relative to where this RPC is.
		 * @method isRemote
		 * @param {string} instanceId The Instance ID
		 * @return {bool} True if there is an open socket
		 *&#x2F;
		isRemote:function(instanceId) {
			return (
				&#x2F;&#x2F; we have an App
				_apps[instanceId] !== undefined &amp;&amp; 
				&#x2F;&#x2F; the App is secure
				_apps[instanceId].app.isSecure &amp;&amp;
				&#x2F;&#x2F; we can&#x27;t access the iframe
				$(&#x27;#&#x27; + instanceId).find(&#x27;iframe&#x27;).length == 0
			);
		},

		&#x2F;**
		 * Creates a Container-to-App or App-to-Container socket for communication
		 * @method register
		 * @param {F2.App} [app] The App object
		 *&#x2F;
		register:function(app, appManifest) {
			if (app) {
				_apps[app.instanceId] = {
					app:app,
					socket:_createContainerToAppSocket(app, appManifest)
				};
			} else {
				F2.log(&quot;Unable to register socket connection. Please check container configuration.&quot;);
			}
		}
	};
})());
    </pre>
</div>

			</div>
		</div>

		<hr>

		<footer>
			<p class="pull-left"><strong><small>F2 helps you build smarter financial applications.</small></strong></p>
			<p class="pull-right"><small>F2 was created and is maintained by <a href="http://www.markit.com/">Markit</a> on <a href="//github.com/OpenF2/F2">GitHub</a>.<br>Code licensed under the <a href="//github.com/OpenF2/F2#copyright-and-license">MIT License</a>.<br> Documentation licensed under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a></small></p>
		</footer>
	</div>
</div>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js"></script>
<script src="http://docs.openf2.com/js/bootstrap.js"></script>
<script src="http://docs.openf2.com/js/prettify.js"></script>
<script src="..&#x2F;assets/js/main.js"></script>
<script>prettyPrint();</script>
</body>
</html>
